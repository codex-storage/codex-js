import { Static, Type } from "@sinclair/typebox"

export type CodexStorageRequest = {
	id: string

	/**
	 * Address of Ethereum address
	 */
	client: string

	ask: {
		/**
		 * Number of slots that the tequest want to have the content spread over.
		 */
		slots: number

		/**
		 * Amount of storage per slot (in bytes) as decimal string.
		 */
		slotSize: string

		/**
		 * The duration of the storage request in seconds.
		 */
		duration: string

		/**
		 * How often storage proofs are required as decimal string (in periods).
		 */
		proofProbability: string

		/**
		 * The maximum amount of tokens paid per second per slot to hosts
		 * the client is willing to pay.
		 */
		reward: string

		/**
		 * Max slots that can be lost without data considered to be lost.
		 */
		maxSlotLoss: number
	},

	content: {
		/**
		 * Unique Content ID
		 */
		cid: string

		/**
		 * Erasure code parameters
		 */
		erasure: {
			/**
			 * Total number of chunks generated by the erasure code process.
			 */
			totalChunks: number
		},

		/**
		 * Parameters for Proof of Retrievability
		 */
		por: {
			u: string
			publicKey: string
			name: string
		}
	},

	/* Number as decimal string that represents expiry threshold in seconds from when the Request is submitted.
	 * When the threshold is reached and the Request does not find requested amount of nodes to host the data, the Request is voided.
	 * The number of seconds can not be higher then the Request's duration itself.
	 */
	expiry: string,

	/**
	 * Random data
	 */
	nonce: string
}

/**
 * A storage slot is a portion of a storage contract that needs to be fulfilled
 * by a host. To initiate a contract, all the slots must be filled.
 */
export type CodexSlot = {
	id: string

	request: CodexStorageRequest,

	/**
	 * The slot index as hexadecimal string
	 */
	slotIndex: "string"
}

/**
 * Storage availability for sell.
 */
export type CodexAvailability = {
	id: string

	/**
	 * Size of available storage in bytes
	 */
	totalSize: string

	/**
	 * Maximum time the storage should be sold for (in seconds)
	 */
	duration: string

	/**
	 * Minimum price to be paid (in amount of tokens)
	 */
	minPrice: string

	/**
	 * Maximum collateral user is willing to pay per filled Slot (in amount of tokens)
	 */
	maxCollateral: string
}

export type CodexAvailabilityCreateResponse = CodexAvailability & {
	id: string

	/**
	 * Unused size of availability's storage in bytes as decimal string
	 */
	freeSize: string
}

export const CodexCreateAvailabilityInput = Type.Object({
	totalSize: Type.Number({ minimum: 1 }),
	duration: Type.Number({ minimum: 1 }),
	minPrice: Type.Number(),
	maxCollateral: Type.Number()
})

export type CodexCreateAvailabilityInput = Static<typeof CodexCreateAvailabilityInput>

export const CodexUpdateAvailabilityInput = Type.Object({
	id: Type.String(),
	totalSize: Type.Optional(Type.Number({ minimum: 1 })),
	duration: Type.Optional(Type.Number({ minimum: 1 })),
	minPrice: Type.Optional(Type.Number()),
	maxCollateral: Type.Optional(Type.Number())
})

export type CodexUpdateAvailabilityInput = Static<typeof CodexUpdateAvailabilityInput>

export type CodexReservation = {
	id: string
	availabilityId: string
	requestId: string

	/**
	 * Size in bytes
	 */
	size: string

	/**
	 * Slot Index as hexadecimal string
	 */
	slotIndex: string
}

export type CodexPurchase = {
	/**
	 * Description of the request's state
	 */
	state: string

	/**
	 * If request failed, then here is presented the error message
	 */
	error: string

	request: CodexStorageRequest
}

export const CodexCreateStorageRequestInput = Type.Object({
	cid: Type.String(),
	duration: Type.Number({ minimum: 1 }),
	reward: Type.Number(),
	proofProbability: Type.Number(),
	nodes: Type.Optional(Type.Number({ default: 1 })),
	tolerance: Type.Optional(Type.Number({ default: 0 })),
	expiry: Type.Number({ minimum: 1 }),
	collateral: Type.Number()
})

export type CodexCreateStorageRequestInput = Static<typeof CodexCreateStorageRequestInput>

export type CodexCreateStorageRequestResponse = Omit<CodexCreateStorageRequestInput, "cid"> 