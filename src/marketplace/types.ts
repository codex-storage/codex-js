import * as v from "valibot";

export type CodexStorageRequest = {
  id: string;

  /**
   * Address of Ethereum address
   */
  client: string;

  ask: {
    /**
     * Number of slots that the tequest want to have the content spread over.
     */
    slots: number;

    /**
     * Amount of storage per slot (in bytes) as decimal string.
     */
    slotSize: string;

    /**
     * The duration of the storage request in seconds.
     */
    duration: string;

    /**
     * How often storage proofs are required as decimal string (in periods).
     */
    proofProbability: string;

    /**
     * The amount of tokens paid per byte per second per slot to hosts the client is willing to pay
     */
    pricePerBytePerSecond: string;

    /**
     * Max slots that can be lost without data considered to be lost.
     */
    maxSlotLoss: number;
  };

  content: {
    /**
     * Unique Content ID
     */
    cid: string;

    /**
     * Erasure code parameters
     */
    // erasure: {
    /**
     * Total number of chunks generated by the erasure code process.
     */
    // totalChunks: number;
    // };

    /**
     * Parameters for Proof of Retrievability
     */
    // por: {
    //   u: string;
    //   publicKey: string;
    //   name: string;
    // };
  };

  /* Number as decimal string that represents expiry threshold in seconds from when the Request is submitted.
   * When the threshold is reached and the Request does not find requested amount of nodes to host the data, the Request is voided.
   * The number of seconds can not be higher then the Request's duration itself.
   */
  expiry: string;

  /**
   * Random data
   */
  nonce: string;
};

/**
 * A storage slot is a portion of a storage contract that needs to be fulfilled
 * by a host. To initiate a contract, all the slots must be filled.
 */
export type CodexSlot = {
  id: string;

  request: CodexStorageRequest;

  /**
   * The slot index as hexadecimal string
   */
  slotIndex: "string";
};

/**
 * Storage availability for sell.
 */
export type CodexAvailability = {
  id: string;

  /**
   * Size of available storage in bytes
   */
  totalSize: number;

  /**
   * Unused size of availability's storage in bytes as decimal string
   */
  freeSize: number;

  /**
   * Maximum time the storage should be sold for (in seconds)
   */
  duration: number;

  /**
   * Minimal price per byte per second paid (in amount of tokens) for the
   * hosted request's slot for the request's duration as decimal string
   */
  minPricePerBytePerSecond: number;

  /**
   * Total collateral (in amount of tokens) that can be used for matching requests
   */
  totalCollateral: number;

  totalRemainingCollateral: number;
};

/**
 * Storage availability received from the api.
 */
export type CodexAvailabilityDto = {
  id: string;

  /**
   * Size of available storage in bytes
   */
  totalSize: string;

  /**
   * Unused size of availability's storage in bytes as decimal string
   */
  freeSize: string;

  /**
   * Maximum time the storage should be sold for (in seconds)
   */
  duration: string;

  /**
   * Minimal price per byte per second paid (in amount of tokens) for the
   * hosted request's slot for the request's duration as decimal string
   */
  minPricePerBytePerSecond: string;

  /**
   * Total collateral (in amount of tokens) that can be used for matching requests
   */
  totalCollateral: string;

  totalRemainingCollateral: string;
};

export type CodexAvailabilityCreateResponse = CodexAvailability & {
  id: string;

  /**
   * Unused size of availability's storage in bytes as decimal string
   */
  freeSize: string;
};

export const CodexCreateAvailabilityInput = v.strictObject({
  totalSize: v.pipe(v.number(), v.minValue(1)),
  duration: v.pipe(v.number(), v.minValue(1)),
  minPrice: v.number(),
  maxCollateral: v.number(),
});

export type CodexCreateAvailabilityInput = v.InferOutput<
  typeof CodexCreateAvailabilityInput
>;

export const CodexUpdateAvailabilityInput = v.strictObject({
  id: v.string(),
  totalSize: v.pipe(v.number(), v.minValue(1)),
  duration: v.pipe(v.number(), v.minValue(1)),
  minPrice: v.number(),
  maxCollateral: v.number(),
});

export type CodexUpdateAvailabilityInput = v.InferOutput<
  typeof CodexUpdateAvailabilityInput
>;

export type CodexReservation = {
  id: string;
  availabilityId: string;
  requestId: string;

  /**
   * Size in bytes
   */
  size: string;

  /**
   * Slot Index as hexadecimal string
   */
  slotIndex: string;
};

export type CodexPurchase = {
  /**
   * Description of the request's state
   */
  state: string;

  /**
   * If request failed, then here is presented the error message
   */
  error: string;

  request: CodexStorageRequest;

  requestId: string;
};

export const CodexCreateStorageRequestInput = v.strictObject({
  cid: v.string(),
  duration: v.pipe(v.number(), v.minValue(1)),
  pricePerBytePerSecond: v.number(),
  proofProbability: v.number(),
  nodes: v.optional(v.number(), 1),
  tolerance: v.optional(v.number(), 0),
  expiry: v.pipe(v.number(), v.minValue(1)),
  collateralPerByte: v.number(),
});

export type CodexCreateStorageRequestInput = v.InferOutput<
  typeof CodexCreateStorageRequestInput
>;
