/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/connect/{peerId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Connect to a peer
         * @description If `addrs` param is supplied, it will be used to dial the peer, otherwise the `peerId` is used
         *     to invoke peer discovery, if it succeeds the returned addresses will be used to dial.
         *
         */
        get: operations["connectPeer"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/data": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Lists manifest CIDs stored locally in node. */
        get: operations["listData"];
        put?: never;
        /** Upload a file in a streaming manner. Once finished, the file is stored in the node and can be retrieved by any node in the network using the returned CID. */
        post: operations["upload"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/data/{cid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Download a file from the local node in a streaming manner. If the file is not available locally, a 404 is returned. */
        get: operations["downloadLocal"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/data/{cid}/network": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Download a file from the network to the local node if it's not available locally. Note: Download is performed async. Call can return before download is completed. */
        post: operations["downloadNetwork"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/data/{cid}/network/stream": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Download a file from the network in a streaming manner. If the file is not available locally, it will be retrieved from other nodes in the network if able. */
        get: operations["downloadNetworkStream"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/data/{cid}/network/manifest": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Download only the dataset manifest from the network to the local node if it's not available locally. */
        get: operations["downloadNetworkManifest"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/space": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets a summary of the storage space allocation of the node. */
        get: operations["space"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sales/slots": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns active slots */
        get: operations["getActiveSlots"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sales/slots/{slotId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns active slot with id {slotId} for the host */
        get: operations["getActiveSlotById"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sales/availability": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns storage that is for sale */
        get: operations["getAvailabilities"];
        put?: never;
        /** Offers storage for sale */
        post: operations["offerStorage"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sales/availability/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Updates availability
         * @description The new parameters will be only considered for new requests.
         *     Existing Requests linked to this Availability will continue as is.
         *
         */
        patch: operations["updateOfferedStorage"];
        trace?: never;
    };
    "/sales/availability/{id}/reservations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get availability's reservations
         * @description Return's list of Reservations for ongoing Storage Requests that the node hosts.
         */
        get: operations["getReservations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/storage/request/{cid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Creates a new Request for storage */
        post: operations["createStorageRequest"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/storage/purchases": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns list of purchase IDs */
        get: operations["getPurchases"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/storage/purchases/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns purchase details */
        get: operations["getPurchase"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/spr": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Node's SPR */
        get: operations["getSPR"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/peerid": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Node's PeerID */
        get: operations["getPeerId"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/debug/chronicles/loglevel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Set log level at run time */
        post: operations["setDebugLogLevel"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/debug/info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets node information */
        get: operations["getDebugInfo"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * @description Address of node as specified by the multi-address specification https://multiformats.io/multiaddr/
         * @example /ip4/127.0.0.1/tcp/8080
         */
        MultiAddress: string;
        /**
         * @description Peer Identity reference as specified at https://docs.libp2p.io/concepts/fundamentals/peers/
         * @example QmYyQSo1c1Ym7orWxLYvCrM2EmxFTANf8wXmmE7DWjhx5N
         */
        PeerId: string;
        /**
         * @description 32bits identifier encoded in hex-decimal string.
         * @example 0x...
         */
        Id: string;
        /**
         * @description Content Identifier as specified at https://github.com/multiformats/cid
         * @example QmYyQSo1c1Ym7orWxLYvCrM2EmxFTANf8wXmmE7DWjhx5N
         */
        Cid: string;
        /**
         * @description Keccak hash of the abi encoded tuple (RequestId, slot index)
         * @example 268a781e0db3f7cf36b18e5f4fdb7f586ec9edd08e5500b17c0e518a769f114a
         */
        SlotId: string;
        /**
         * @description One of the log levels: TRACE, DEBUG, INFO, NOTICE, WARN, ERROR or FATAL
         * @example DEBUG
         */
        LogLevel: string;
        /** @description Address of Ethereum address */
        EthereumAddress: string;
        /** @description The amount of tokens paid per byte per second per slot to hosts the client is willing to pay */
        PricePerBytePerSecond: string;
        /**
         * Format: int64
         * @description The duration of the request in seconds
         */
        Duration: number;
        /** @description How often storage proofs are required as decimal string */
        ProofProbability: string;
        /**
         * Format: int64
         * @description A timestamp as seconds since unix epoch at which this request expires if the Request does not find requested amount of nodes to host the data.
         */
        Expiry: number;
        /** @description Signed Peer Record (libp2p) */
        SPR: string;
        SPRRead: {
            spr: components["schemas"]["SPR"];
        };
        PeerIdRead: {
            id?: components["schemas"]["PeerId"];
        };
        /** @description Parameters specifying the content */
        Content: {
            cid: components["schemas"]["Cid"];
        };
        Node: {
            nodeId: string;
            peerId: string;
            record: string;
            address: string;
            seen: boolean;
        };
        CodexVersion: {
            /** @example v0.1.7 */
            version?: string;
            /** @example 0c647d8 */
            revision?: string;
        };
        PeersTable: {
            localNode: components["schemas"]["Node"];
            nodes: components["schemas"]["Node"][];
        };
        DebugInfo: {
            id: components["schemas"]["PeerId"];
            addrs: components["schemas"]["MultiAddress"][];
            /** @description Path of the data repository where all nodes data are stored */
            repo: string;
            spr: components["schemas"]["SPR"];
            announceAddresses: components["schemas"]["MultiAddress"][];
            table: components["schemas"]["PeersTable"];
            codex: components["schemas"]["CodexVersion"];
        };
        SalesAvailability: {
            /**
             * Format: int64
             * @description Total size of availability's storage in bytes
             */
            totalSize: number;
            duration: components["schemas"]["Duration"];
            /** @description Minimal price per byte per second paid (in amount of tokens) for the hosted request's slot for the request's duration as decimal string */
            minPricePerBytePerSecond: string;
            /** @description Total collateral (in amount of tokens) that can be used for matching requests */
            totalCollateral: string;
            /**
             * @description Enable the ability to receive sales on this availability.
             * @default true
             */
            enabled?: boolean;
            /**
             * @description Specifies the latest timestamp, after which the availability will no longer host any slots. If set to 0, there will be no restrictions.
             * @default 0
             */
            until?: number;
        };
        SalesAvailabilityREAD: components["schemas"]["SalesAvailability"] & {
            id: components["schemas"]["Id"];
            /**
             * Format: int64
             * @description Unused size of availability's storage in bytes as decimal string
             */
            readonly freeSize?: number;
            /** @description Total collateral effective (in amount of tokens) that can be used for matching requests */
            readonly totalRemainingCollateral: string;
        };
        Slot: {
            id: components["schemas"]["SlotId"];
            request: components["schemas"]["StorageRequest"];
            /**
             * Format: int64
             * @description Slot Index number
             */
            slotIndex: number;
        };
        SlotAgent: {
            /**
             * Format: int64
             * @description Slot Index number
             */
            slotIndex: number;
            requestId: components["schemas"]["Id"];
            request?: components["schemas"]["StorageRequest"];
            reservation?: components["schemas"]["Reservation"];
            /**
             * @description Description of the slot's
             * @enum {string}
             */
            state: "SaleCancelled" | "SaleDownloading" | "SaleErrored" | "SaleFailed" | "SaleFilled" | "SaleFilling" | "SaleFinished" | "SaleIgnored" | "SaleInitialProving" | "SalePayout" | "SalePreparing" | "SaleProving" | "SaleUnknown";
        };
        Reservation: {
            id: components["schemas"]["Id"];
            availabilityId: components["schemas"]["Id"];
            /**
             * Format: int64
             * @description Size of the slot in bytes
             */
            size: number;
            requestId: components["schemas"]["Id"];
            /**
             * Format: int64
             * @description Slot Index number
             */
            slotIndex: number;
            /** @description Timestamp after which the reservation will no longer be valid. */
            validUntil: number;
        };
        StorageRequestCreation: {
            duration: components["schemas"]["Duration"];
            pricePerBytePerSecond: components["schemas"]["PricePerBytePerSecond"];
            proofProbability: components["schemas"]["ProofProbability"];
            /**
             * @description Minimal number of nodes the content should be stored on
             * @default 3
             */
            nodes?: number;
            /**
             * @description Additional number of nodes on top of the `nodes` property that can be lost before pronouncing the content lost
             * @default 1
             */
            tolerance?: number;
            /** @description Number as decimal string that represents how much collateral per byte is asked from hosts that wants to fill a slots */
            collateralPerByte: string;
            /**
             * Format: int64
             * @description Number that represents expiry threshold in seconds from when the Request is submitted. When the threshold is reached and the Request does not find requested amount of nodes to host the data, the Request is voided. The number of seconds can not be higher then the Request's duration itself.
             */
            expiry: number;
        };
        StorageAsk: {
            /**
             * Format: int64
             * @description Number of slots (eq. hosts) that the Request want to have the content spread over
             */
            slots: number;
            /**
             * Format: int64
             * @description Amount of storage per slot in bytes
             */
            slotSize: number;
            duration: components["schemas"]["Duration"];
            proofProbability: components["schemas"]["ProofProbability"];
            pricePerBytePerSecond: components["schemas"]["PricePerBytePerSecond"];
            /**
             * Format: int64
             * @description Max slots that can be lost without data considered to be lost
             */
            maxSlotLoss: number;
        };
        StorageRequest: {
            /** @description Request ID */
            id: string;
            client: components["schemas"]["EthereumAddress"];
            ask: components["schemas"]["StorageAsk"];
            content: components["schemas"]["Content"];
            expiry: components["schemas"]["Expiry"];
            /** @description Random data */
            nonce: string;
        };
        Purchase: {
            /**
             * @description Description of the Request's state
             * @enum {string}
             */
            state: "cancelled" | "error" | "failed" | "finished" | "pending" | "started" | "submitted" | "unknown";
            /** @description If Request failed, then here is presented the error message */
            error?: string | null;
            request?: components["schemas"]["StorageRequest"];
            requestId: components["schemas"]["Id"];
        };
        DataList: {
            content: components["schemas"]["DataItem"][];
        };
        DataItem: {
            cid: components["schemas"]["Cid"];
            manifest: components["schemas"]["ManifestItem"];
        };
        ManifestItem: {
            /** @description Unique data identifier */
            treeCid: components["schemas"]["Cid"];
            /**
             * Format: int64
             * @description Length of original content in bytes
             */
            datasetSize: number;
            /** @description Size of blocks */
            blockSize: number;
            /** @description Indicates if content is protected by erasure-coding */
            protected: boolean;
            /**
             * @description The original name of the uploaded content (optional)
             * @example codex.png
             */
            filename?: string | null;
            /**
             * @description The original mimetype of the uploaded content (optional)
             * @example image/png
             */
            mimetype?: string | null;
        };
        Space: {
            /**
             * Format: int64
             * @description Number of blocks stored by the node
             */
            totalBlocks: number;
            /**
             * Format: int64
             * @description Maximum storage space (in bytes) available for the node in Codex's local repository.
             */
            quotaMaxBytes: number;
            /**
             * Format: int64
             * @description Amount of storage space (in bytes) currently used for storing files in Codex's local repository.
             */
            quotaUsedBytes: number;
            /**
             * Format: int64
             * @description Amount of storage reserved (in bytes) in the Codex's local repository for future use when storage requests will be picked up and hosted by the node using node's availabilities. This does not include the storage currently in use.
             */
            quotaReservedBytes: number;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    connectPeer: {
        parameters: {
            query?: {
                /** @description If supplied, it will be used to dial the peer.
                 *     The address has to target the listening address of the peer,
                 *     which is specified with the `--listen-addrs` CLI flag.
                 *      */
                addrs?: components["schemas"]["MultiAddress"][] | null;
            };
            header?: never;
            path: {
                /** @description Peer that should be dialed. */
                peerId: components["schemas"]["PeerId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successfully connected to peer */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Peer either not found or was not possible to dial */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    listData: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Retrieved list of content CIDs */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DataList"];
                };
            };
            /** @description Invalid CID is specified */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Content specified by the CID is not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description The content type is not a valid content type or the filename is not valid */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Well it was bad-bad */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    upload: {
        parameters: {
            query?: never;
            header?: {
                /** @description The content type of the file. Must be valid. */
                "content-type"?: string;
                /** @description The content disposition used to send the filename. */
                "content-disposition"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/octet-stream": string;
            };
        };
        responses: {
            /** @description CID of uploaded file */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/plain": string;
                };
            };
            /** @description Well it was bad-bad and the upload did not work out */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    downloadLocal: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description File to be downloaded. */
                cid: components["schemas"]["Cid"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Retrieved content specified by CID */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/octet-stream": string;
                };
            };
            /** @description Invalid CID is specified */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Content specified by the CID is unavailable locally */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Well it was bad-bad */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    downloadNetwork: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description File to be downloaded. */
                cid: components["schemas"]["Cid"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Manifest information for download that has been started. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DataItem"];
                };
            };
            /** @description Invalid CID is specified */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Failed to download dataset manifest */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Well it was bad-bad */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    downloadNetworkStream: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description File to be downloaded. */
                cid: components["schemas"]["Cid"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Retrieved content specified by CID */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/octet-stream": string;
                };
            };
            /** @description Invalid CID is specified */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Content specified by the CID is not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Well it was bad-bad */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    downloadNetworkManifest: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description File for which the manifest is to be downloaded. */
                cid: components["schemas"]["Cid"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Manifest information. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DataItem"];
                };
            };
            /** @description Invalid CID is specified */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Failed to download dataset manifest */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Well it was bad-bad */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    space: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Summary of storage allocation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Space"];
                };
            };
            /** @description It's not working as planned */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getActiveSlots: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Retrieved active slots */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Slot"][];
                };
            };
            /** @description Persistence is not enabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getActiveSlotById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description File to be downloaded. */
                slotId: components["schemas"]["Cid"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Retrieved active slot */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SlotAgent"];
                };
            };
            /** @description Invalid or missing SlotId */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Host is not in an active sale for the slot */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Persistence is not enabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getAvailabilities: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Retrieved storage availabilities of the node */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SalesAvailabilityREAD"][];
                };
            };
            /** @description Error getting unused availabilities */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Persistence is not enabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    offerStorage: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["SalesAvailability"];
            };
        };
        responses: {
            /** @description Created storage availability */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SalesAvailabilityREAD"];
                };
            };
            /** @description Invalid data input */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not enough node's storage quota available or the provided parameters did not pass validation */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error reserving availability */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Persistence is not enabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    updateOfferedStorage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of Availability */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["SalesAvailability"];
            };
        };
        responses: {
            /** @description Availability successfully updated */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid data input */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Availability not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description The provided parameters did not pass validation */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error reserving availability */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Persistence is not enabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getReservations: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of Availability */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Retrieved storage availabilities of the node */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Reservation"][];
                };
            };
            /** @description Invalid Availability ID */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Availability not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error getting reservations */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Persistence is not enabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createStorageRequest: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description CID of the uploaded data that should be stored */
                cid: components["schemas"]["Cid"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["StorageRequestCreation"];
            };
        };
        responses: {
            /** @description Returns the Request ID as decimal string */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/plain": string;
                };
            };
            /** @description Invalid or missing Request ID */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Request ID not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description The storage request parameters are not valid */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Persistence is not enabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getPurchases: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Gets all purchase IDs stored in node */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": string[];
                };
            };
            /** @description Persistence is not enabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getPurchase: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Hexadecimal ID of a Purchase */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Purchase details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Purchase"];
                };
            };
            /** @description Invalid or missing Purchase ID */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Purchase not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Persistence is not enabled */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSPR: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Node's SPR */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/plain": components["schemas"]["SPR"];
                    "application/json": components["schemas"]["SPRRead"];
                };
            };
            /** @description Node SPR not ready, try again later */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getPeerId: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Node's Peer ID */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/plain": components["schemas"]["PeerId"];
                    "application/json": components["schemas"]["PeerIdRead"];
                };
            };
        };
    };
    setDebugLogLevel: {
        parameters: {
            query: {
                level: components["schemas"]["LogLevel"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successfully log level set */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid or missing log level */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Well it was bad-bad */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getDebugInfo: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Node's information */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DebugInfo"];
                };
            };
        };
    };
}
